{"ast":null,"code":"'use strict';\n\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar _excluded = [\"animationName\"];\nimport { convertPropertiesToArrays, kebabizeCamelCase } from \"../../utils\";\nimport { processKeyframeDefinitions } from \"../animationParser\";\nimport { configureWebCSSAnimations, insertCSSAnimation, removeCSSAnimation } from \"../domUtils\";\nimport { CSSKeyframesRuleImpl } from \"../keyframes\";\nimport { maybeAddSuffixes, parseTimingFunction } from \"../utils\";\nvar isCSSKeyframesRuleImpl = function isCSSKeyframesRuleImpl(keyframes) {\n  return typeof keyframes === 'object' && 'processedKeyframes' in keyframes;\n};\nvar CSSAnimationsManager = function () {\n  function CSSAnimationsManager(element) {\n    _classCallCheck(this, CSSAnimationsManager);\n    this.attachedAnimations = {};\n    configureWebCSSAnimations();\n    this.element = element;\n  }\n  return _createClass(CSSAnimationsManager, [{\n    key: \"update\",\n    value: function update(animationProperties) {\n      var _this = this;\n      if (!animationProperties) {\n        this.detach();\n        return;\n      }\n      var _convertPropertiesToA = convertPropertiesToArrays(animationProperties),\n        definitions = _convertPropertiesToA.animationName,\n        animationSettings = _objectWithoutProperties(_convertPropertiesToA, _excluded);\n      if (definitions.length === 0) {\n        this.detach();\n        return;\n      }\n      var processedAnimations = definitions.map(function (definition) {\n        if (isCSSKeyframesRuleImpl(definition)) {\n          return {\n            keyframesRule: definition,\n            removable: false\n          };\n        }\n        var keyframes = definition;\n        var processedKeyframes = processKeyframeDefinitions(keyframes);\n        if (_this.attachedAnimations[processedKeyframes]) {\n          return {\n            keyframesRule: _this.attachedAnimations[processedKeyframes].keyframesRule,\n            removable: true\n          };\n        }\n        return {\n          keyframesRule: new CSSKeyframesRuleImpl(keyframes, processedKeyframes),\n          removable: true\n        };\n      });\n      var animationNames = processedAnimations.map(function (_ref) {\n        var name = _ref.keyframesRule.name;\n        return name;\n      });\n      this.updateAttachedAnimations(processedAnimations);\n      this.setElementAnimations(animationNames, animationSettings);\n    }\n  }, {\n    key: \"unmountCleanup\",\n    value: function unmountCleanup() {\n      setTimeout(this.detach.bind(this));\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      var attachedAnimations = Object.values(this.attachedAnimations);\n      if (attachedAnimations.length === 0) {\n        return;\n      }\n      this.element.style.animationDuration = '';\n      this.element.style.animationDelay = '';\n      this.element.style.animationDirection = '';\n      this.element.style.animationFillMode = '';\n      this.element.style.animationPlayState = '';\n      this.element.style.animationTimingFunction = '';\n      attachedAnimations.forEach(function (_ref2) {\n        var _ref2$keyframesRule = _ref2.keyframesRule,\n          name = _ref2$keyframesRule.name,\n          processedKeyframes = _ref2$keyframesRule.processedKeyframes,\n          removable = _ref2.removable;\n        if (removable && processedKeyframes) {\n          removeCSSAnimation(name);\n        }\n      });\n      this.attachedAnimations = {};\n    }\n  }, {\n    key: \"updateAttachedAnimations\",\n    value: function updateAttachedAnimations(processedAnimations) {\n      var newAttachedAnimations = {};\n      processedAnimations.forEach(function (processedAnimation) {\n        var rule = processedAnimation.keyframesRule;\n        if (rule.processedKeyframes) {\n          insertCSSAnimation(rule.name, rule.processedKeyframes);\n        }\n        newAttachedAnimations[rule.processedKeyframes] = processedAnimation;\n      });\n      Object.values(this.attachedAnimations).forEach(function (_ref3) {\n        var rule = _ref3.keyframesRule,\n          removable = _ref3.removable;\n        if (removable && rule.processedKeyframes && !newAttachedAnimations[rule.processedKeyframes]) {\n          removeCSSAnimation(rule.name);\n        }\n      });\n      this.attachedAnimations = newAttachedAnimations;\n    }\n  }, {\n    key: \"setElementAnimations\",\n    value: function setElementAnimations(animationNames, animationSettings) {\n      this.element.style.animationName = animationNames.join(',');\n      this.element.style.animationDuration = maybeAddSuffixes(animationSettings, 'animationDuration', 'ms').join(',');\n      this.element.style.animationDelay = maybeAddSuffixes(animationSettings, 'animationDelay', 'ms').join(',');\n      if (animationSettings.animationIterationCount) {\n        this.element.style.animationIterationCount = animationSettings.animationIterationCount.join(',');\n      }\n      if (animationSettings.animationDirection) {\n        this.element.style.animationDirection = animationSettings.animationDirection.map(kebabizeCamelCase).join(',');\n      }\n      if (animationSettings.animationFillMode) {\n        this.element.style.animationFillMode = animationSettings.animationFillMode.join(',');\n      }\n      if (animationSettings.animationPlayState) {\n        this.element.style.animationPlayState = animationSettings.animationPlayState.join(',');\n      }\n      if (animationSettings.animationTimingFunction) {\n        this.element.style.animationTimingFunction = parseTimingFunction(animationSettings.animationTimingFunction);\n      }\n    }\n  }]);\n}();\nexport { CSSAnimationsManager as default };","map":{"version":3,"names":["_objectWithoutProperties","_classCallCheck","_createClass","_excluded","convertPropertiesToArrays","kebabizeCamelCase","processKeyframeDefinitions","configureWebCSSAnimations","insertCSSAnimation","removeCSSAnimation","CSSKeyframesRuleImpl","maybeAddSuffixes","parseTimingFunction","isCSSKeyframesRuleImpl","keyframes","CSSAnimationsManager","element","attachedAnimations","key","value","update","animationProperties","_this","detach","_convertPropertiesToA","definitions","animationName","animationSettings","length","processedAnimations","map","definition","keyframesRule","removable","processedKeyframes","animationNames","_ref","name","updateAttachedAnimations","setElementAnimations","unmountCleanup","setTimeout","bind","Object","values","style","animationDuration","animationDelay","animationDirection","animationFillMode","animationPlayState","animationTimingFunction","forEach","_ref2","_ref2$keyframesRule","newAttachedAnimations","processedAnimation","rule","_ref3","join","animationIterationCount","default"],"sources":["C:\\Users\\asus\\Desktop\\V.E.T\\node_modules\\react-native-reanimated\\src\\css\\web\\managers\\CSSAnimationsManager.ts"],"sourcesContent":["'use strict';\nimport type { ReanimatedHTMLElement } from '../../../ReanimatedModule/js-reanimated';\nimport type {\n  ConvertValuesToArrays,\n  CSSAnimationKeyframes,\n  CSSAnimationSettings,\n  ExistingCSSAnimationProperties,\n  ICSSAnimationsManager,\n} from '../../types';\nimport { convertPropertiesToArrays, kebabizeCamelCase } from '../../utils';\nimport { processKeyframeDefinitions } from '../animationParser';\nimport {\n  configureWebCSSAnimations,\n  insertCSSAnimation,\n  removeCSSAnimation,\n} from '../domUtils';\nimport { CSSKeyframesRuleImpl } from '../keyframes';\nimport { maybeAddSuffixes, parseTimingFunction } from '../utils';\n\nconst isCSSKeyframesRuleImpl = (\n  keyframes: ExistingCSSAnimationProperties['animationName']\n): keyframes is CSSKeyframesRuleImpl =>\n  typeof keyframes === 'object' && 'processedKeyframes' in keyframes;\n\ntype ProcessedAnimation = {\n  keyframesRule: CSSKeyframesRuleImpl;\n  removable: boolean;\n};\n\ntype ProcessedSettings = ConvertValuesToArrays<CSSAnimationSettings>;\n\nexport default class CSSAnimationsManager implements ICSSAnimationsManager {\n  private readonly element: ReanimatedHTMLElement;\n\n  // Keys are processed keyframes\n  private attachedAnimations: Record<string, ProcessedAnimation> = {};\n\n  constructor(element: ReanimatedHTMLElement) {\n    configureWebCSSAnimations();\n\n    this.element = element;\n  }\n\n  update(animationProperties: ExistingCSSAnimationProperties | null) {\n    if (!animationProperties) {\n      this.detach();\n      return;\n    }\n\n    const { animationName: definitions, ...animationSettings } =\n      convertPropertiesToArrays(animationProperties);\n\n    if (definitions.length === 0) {\n      this.detach();\n      return;\n    }\n\n    const processedAnimations = definitions.map((definition) => {\n      // If the CSSKeyframesRule instance was provided, we can just use it\n      if (isCSSKeyframesRuleImpl(definition)) {\n        return { keyframesRule: definition, removable: false };\n      }\n\n      // If keyframes was defined as an object, the additional processing is needed\n      const keyframes = definition as CSSAnimationKeyframes;\n      const processedKeyframes = processKeyframeDefinitions(keyframes);\n\n      // If the animation with the same keyframes was already attached, we can reuse it\n      if (this.attachedAnimations[processedKeyframes]) {\n        return {\n          keyframesRule:\n            this.attachedAnimations[processedKeyframes].keyframesRule,\n          removable: true,\n        };\n      }\n\n      // Otherwise, we need to create a new CSSKeyframesRule object\n      return {\n        keyframesRule: new CSSKeyframesRuleImpl(keyframes, processedKeyframes),\n        removable: true,\n      };\n    });\n\n    const animationNames = processedAnimations.map(\n      ({ keyframesRule: { name } }) => name\n    );\n\n    this.updateAttachedAnimations(processedAnimations);\n    this.setElementAnimations(animationNames, animationSettings);\n  }\n\n  unmountCleanup(): void {\n    // We use setTimeout to ensure that the animation is removed after the\n    // component is unmounted (it puts the detach call at the end of the event loop)\n    setTimeout(this.detach.bind(this));\n  }\n\n  private detach() {\n    const attachedAnimations = Object.values(this.attachedAnimations);\n\n    if (attachedAnimations.length === 0) {\n      return;\n    }\n\n    this.element.style.animationDuration = '';\n    this.element.style.animationDelay = '';\n    this.element.style.animationDirection = '';\n    this.element.style.animationFillMode = '';\n    this.element.style.animationPlayState = '';\n    this.element.style.animationTimingFunction = '';\n\n    attachedAnimations.forEach(\n      ({ keyframesRule: { name, processedKeyframes }, removable }) => {\n        if (removable && processedKeyframes) {\n          removeCSSAnimation(name);\n        }\n      }\n    );\n    this.attachedAnimations = {};\n  }\n\n  private updateAttachedAnimations(processedAnimations: ProcessedAnimation[]) {\n    const newAttachedAnimations: Record<string, ProcessedAnimation> = {};\n\n    processedAnimations.forEach((processedAnimation) => {\n      const rule = processedAnimation.keyframesRule;\n      if (rule.processedKeyframes) {\n        // We always call insert as it will insert animation only if it doesn't exist\n        insertCSSAnimation(rule.name, rule.processedKeyframes);\n      }\n      newAttachedAnimations[rule.processedKeyframes] = processedAnimation;\n    });\n\n    Object.values(this.attachedAnimations).forEach(\n      ({ keyframesRule: rule, removable }) => {\n        if (\n          removable &&\n          rule.processedKeyframes &&\n          !newAttachedAnimations[rule.processedKeyframes]\n        ) {\n          removeCSSAnimation(rule.name);\n        }\n      }\n    );\n\n    this.attachedAnimations = newAttachedAnimations;\n  }\n\n  private setElementAnimations(\n    animationNames: string[],\n    animationSettings: ProcessedSettings\n  ) {\n    this.element.style.animationName = animationNames.join(',');\n\n    this.element.style.animationDuration = maybeAddSuffixes(\n      animationSettings,\n      'animationDuration',\n      'ms'\n    ).join(',');\n\n    this.element.style.animationDelay = maybeAddSuffixes(\n      animationSettings,\n      'animationDelay',\n      'ms'\n    ).join(',');\n\n    if (animationSettings.animationIterationCount) {\n      this.element.style.animationIterationCount =\n        animationSettings.animationIterationCount.join(',');\n    }\n\n    if (animationSettings.animationDirection) {\n      this.element.style.animationDirection =\n        animationSettings.animationDirection.map(kebabizeCamelCase).join(',');\n    }\n\n    if (animationSettings.animationFillMode) {\n      this.element.style.animationFillMode =\n        animationSettings.animationFillMode.join(',');\n    }\n\n    if (animationSettings.animationPlayState) {\n      this.element.style.animationPlayState =\n        animationSettings.animationPlayState.join(',');\n    }\n\n    if (animationSettings.animationTimingFunction) {\n      this.element.style.animationTimingFunction = parseTimingFunction(\n        animationSettings.animationTimingFunction\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}