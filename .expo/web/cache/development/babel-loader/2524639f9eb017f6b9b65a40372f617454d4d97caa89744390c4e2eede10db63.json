{"ast":null,"code":"'use strict';\n\nimport { ReanimatedError } from \"../../../../common\";\nimport { deepEqual, isNumber } from \"../../../utils\";\nimport { normalizeDelay, normalizeDuration, normalizeTimingFunction } from \"../common\";\nimport { VALID_ANIMATION_DIRECTIONS, VALID_FILL_MODES, VALID_PLAY_STATES } from \"./constants\";\nexport var ERROR_MESSAGES = {\n  invalidAnimationDirection: function invalidAnimationDirection(direction) {\n    return `Invalid animation direction \"${direction}\".`;\n  },\n  invalidIterationCount: function invalidIterationCount(iterationCount) {\n    return `Invalid iteration count \"${iterationCount}\". Expected a number or \"infinite\".`;\n  },\n  negativeIterationCount: function negativeIterationCount(iterationCount) {\n    return `Iteration count cannot be negative, received \"${iterationCount}\".`;\n  },\n  invalidFillMode: function invalidFillMode(fillMode) {\n    return `Invalid fill mode \"${fillMode}\".`;\n  },\n  invalidPlayState: function invalidPlayState(playState) {\n    return `Invalid play state \"${playState}\".`;\n  }\n};\nexport function normalizeDirection() {\n  var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'normal';\n  if (!VALID_ANIMATION_DIRECTIONS.has(direction)) {\n    throw new ReanimatedError(ERROR_MESSAGES.invalidAnimationDirection(direction));\n  }\n  return direction;\n}\nexport function normalizeIterationCount() {\n  var iterationCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  if (iterationCount === 'infinite' || iterationCount === Infinity) {\n    return -1;\n  } else if (!isNumber(iterationCount)) {\n    throw new ReanimatedError(ERROR_MESSAGES.invalidIterationCount(iterationCount));\n  } else if (iterationCount < 0) {\n    throw new ReanimatedError(ERROR_MESSAGES.negativeIterationCount(iterationCount));\n  }\n  return iterationCount;\n}\nexport function normalizeFillMode() {\n  var fillMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'none';\n  if (!VALID_FILL_MODES.has(fillMode)) {\n    throw new ReanimatedError(ERROR_MESSAGES.invalidFillMode(fillMode));\n  }\n  return fillMode;\n}\nexport function normalizePlayState() {\n  var playState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'running';\n  if (!VALID_PLAY_STATES.has(playState)) {\n    throw new ReanimatedError(ERROR_MESSAGES.invalidPlayState(playState));\n  }\n  return playState;\n}\nexport function normalizeSingleCSSAnimationSettings(_ref) {\n  var animationDuration = _ref.animationDuration,\n    animationTimingFunction = _ref.animationTimingFunction,\n    animationDelay = _ref.animationDelay,\n    animationIterationCount = _ref.animationIterationCount,\n    animationDirection = _ref.animationDirection,\n    animationFillMode = _ref.animationFillMode,\n    animationPlayState = _ref.animationPlayState;\n  return {\n    duration: normalizeDuration(animationDuration),\n    timingFunction: normalizeTimingFunction(animationTimingFunction),\n    delay: normalizeDelay(animationDelay),\n    iterationCount: normalizeIterationCount(animationIterationCount),\n    direction: normalizeDirection(animationDirection),\n    fillMode: normalizeFillMode(animationFillMode),\n    playState: normalizePlayState(animationPlayState)\n  };\n}\nexport function getAnimationSettingsUpdates(oldConfig, newConfig) {\n  var updatedSettings = {};\n  if (oldConfig.duration !== newConfig.duration) {\n    updatedSettings.duration = newConfig.duration;\n  }\n  if (oldConfig.timingFunction !== newConfig.timingFunction && (typeof oldConfig.timingFunction !== 'object' || !deepEqual(oldConfig.timingFunction, newConfig.timingFunction))) {\n    updatedSettings.timingFunction = newConfig.timingFunction;\n  }\n  if (oldConfig.delay !== newConfig.delay) {\n    updatedSettings.delay = newConfig.delay;\n  }\n  if (oldConfig.iterationCount !== newConfig.iterationCount) {\n    updatedSettings.iterationCount = newConfig.iterationCount;\n  }\n  if (oldConfig.direction !== newConfig.direction) {\n    updatedSettings.direction = newConfig.direction;\n  }\n  if (oldConfig.fillMode !== newConfig.fillMode) {\n    updatedSettings.fillMode = newConfig.fillMode;\n  }\n  if (oldConfig.playState !== newConfig.playState) {\n    updatedSettings.playState = newConfig.playState;\n  }\n  return updatedSettings;\n}","map":{"version":3,"names":["ReanimatedError","deepEqual","isNumber","normalizeDelay","normalizeDuration","normalizeTimingFunction","VALID_ANIMATION_DIRECTIONS","VALID_FILL_MODES","VALID_PLAY_STATES","ERROR_MESSAGES","invalidAnimationDirection","direction","invalidIterationCount","iterationCount","negativeIterationCount","invalidFillMode","fillMode","invalidPlayState","playState","normalizeDirection","arguments","length","undefined","has","normalizeIterationCount","Infinity","normalizeFillMode","normalizePlayState","normalizeSingleCSSAnimationSettings","_ref","animationDuration","animationTimingFunction","animationDelay","animationIterationCount","animationDirection","animationFillMode","animationPlayState","duration","timingFunction","delay","getAnimationSettingsUpdates","oldConfig","newConfig","updatedSettings"],"sources":["C:\\Users\\asus\\Desktop\\V.E.T\\node_modules\\react-native-reanimated\\src\\css\\native\\normalization\\animation\\settings.ts"],"sourcesContent":["'use strict';\nimport { ReanimatedError } from '../../../../common';\nimport type {\n  CSSAnimationDirection,\n  CSSAnimationFillMode,\n  CSSAnimationIterationCount,\n  CSSAnimationPlayState,\n  SingleCSSAnimationSettings,\n} from '../../../types';\nimport { deepEqual, isNumber } from '../../../utils';\nimport type { NormalizedSingleCSSAnimationSettings } from '../../types';\nimport {\n  normalizeDelay,\n  normalizeDuration,\n  normalizeTimingFunction,\n} from '../common';\nimport {\n  VALID_ANIMATION_DIRECTIONS,\n  VALID_FILL_MODES,\n  VALID_PLAY_STATES,\n} from './constants';\n\nexport const ERROR_MESSAGES = {\n  invalidAnimationDirection: (direction: CSSAnimationDirection) =>\n    `Invalid animation direction \"${direction}\".`,\n  invalidIterationCount: (iterationCount: CSSAnimationIterationCount) =>\n    `Invalid iteration count \"${iterationCount}\". Expected a number or \"infinite\".`,\n  negativeIterationCount: (iterationCount: number) =>\n    `Iteration count cannot be negative, received \"${iterationCount}\".`,\n  invalidFillMode: (fillMode: CSSAnimationFillMode) =>\n    `Invalid fill mode \"${fillMode}\".`,\n  invalidPlayState: (playState: CSSAnimationPlayState) =>\n    `Invalid play state \"${playState}\".`,\n};\n\nexport function normalizeDirection(\n  direction: CSSAnimationDirection = 'normal'\n): CSSAnimationDirection {\n  if (!VALID_ANIMATION_DIRECTIONS.has(direction)) {\n    throw new ReanimatedError(\n      ERROR_MESSAGES.invalidAnimationDirection(direction)\n    );\n  }\n  return direction;\n}\n\nexport function normalizeIterationCount(\n  iterationCount: CSSAnimationIterationCount = 1\n): number {\n  if (iterationCount === 'infinite' || iterationCount === Infinity) {\n    return -1;\n  } else if (!isNumber(iterationCount)) {\n    throw new ReanimatedError(\n      ERROR_MESSAGES.invalidIterationCount(iterationCount)\n    );\n  } else if (iterationCount < 0) {\n    throw new ReanimatedError(\n      ERROR_MESSAGES.negativeIterationCount(iterationCount)\n    );\n  }\n  return iterationCount;\n}\n\nexport function normalizeFillMode(\n  fillMode: CSSAnimationFillMode = 'none'\n): CSSAnimationFillMode {\n  if (!VALID_FILL_MODES.has(fillMode)) {\n    throw new ReanimatedError(ERROR_MESSAGES.invalidFillMode(fillMode));\n  }\n  return fillMode;\n}\n\nexport function normalizePlayState(\n  playState: CSSAnimationPlayState = 'running'\n): CSSAnimationPlayState {\n  if (!VALID_PLAY_STATES.has(playState)) {\n    throw new ReanimatedError(ERROR_MESSAGES.invalidPlayState(playState));\n  }\n  return playState;\n}\n\nexport function normalizeSingleCSSAnimationSettings({\n  animationDuration,\n  animationTimingFunction,\n  animationDelay,\n  animationIterationCount,\n  animationDirection,\n  animationFillMode,\n  animationPlayState,\n}: SingleCSSAnimationSettings): NormalizedSingleCSSAnimationSettings {\n  return {\n    duration: normalizeDuration(animationDuration),\n    timingFunction: normalizeTimingFunction(animationTimingFunction),\n    delay: normalizeDelay(animationDelay),\n    iterationCount: normalizeIterationCount(animationIterationCount),\n    direction: normalizeDirection(animationDirection),\n    fillMode: normalizeFillMode(animationFillMode),\n    playState: normalizePlayState(animationPlayState),\n  };\n}\n\nexport function getAnimationSettingsUpdates(\n  oldConfig: NormalizedSingleCSSAnimationSettings,\n  newConfig: NormalizedSingleCSSAnimationSettings\n): Partial<NormalizedSingleCSSAnimationSettings> {\n  const updatedSettings: Partial<NormalizedSingleCSSAnimationSettings> = {};\n\n  if (oldConfig.duration !== newConfig.duration) {\n    updatedSettings.duration = newConfig.duration;\n  }\n  if (\n    oldConfig.timingFunction !== newConfig.timingFunction &&\n    (typeof oldConfig.timingFunction !== 'object' ||\n      // TODO - maybe replace by some better solution than deepEqual\n      !deepEqual(oldConfig.timingFunction, newConfig.timingFunction))\n  ) {\n    updatedSettings.timingFunction = newConfig.timingFunction;\n  }\n  if (oldConfig.delay !== newConfig.delay) {\n    updatedSettings.delay = newConfig.delay;\n  }\n  if (oldConfig.iterationCount !== newConfig.iterationCount) {\n    updatedSettings.iterationCount = newConfig.iterationCount;\n  }\n  if (oldConfig.direction !== newConfig.direction) {\n    updatedSettings.direction = newConfig.direction;\n  }\n  if (oldConfig.fillMode !== newConfig.fillMode) {\n    updatedSettings.fillMode = newConfig.fillMode;\n  }\n  if (oldConfig.playState !== newConfig.playState) {\n    updatedSettings.playState = newConfig.playState;\n  }\n\n  return updatedSettings;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}