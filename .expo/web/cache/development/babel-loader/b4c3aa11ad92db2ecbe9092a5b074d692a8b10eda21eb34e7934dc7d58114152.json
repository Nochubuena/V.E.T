{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { cssKeyframesRegistry, CSSKeyframesRuleImpl } from \"../keyframes\";\nimport { createSingleCSSAnimationProperties, getAnimationSettingsUpdates, normalizeSingleCSSAnimationSettings } from \"../normalization\";\nimport { applyCSSAnimations, unregisterCSSAnimations } from \"../proxy\";\nvar CSSAnimationsManager = function () {\n  function CSSAnimationsManager(shadowNodeWrapper, viewName, viewTag) {\n    _classCallCheck(this, CSSAnimationsManager);\n    this.attachedAnimations = [];\n    this.shadowNodeWrapper = shadowNodeWrapper;\n    this.viewName = viewName;\n    this.viewTag = viewTag;\n  }\n  return _createClass(CSSAnimationsManager, [{\n    key: \"update\",\n    value: function update(animationProperties) {\n      if (!animationProperties) {\n        this.detach();\n        return;\n      }\n      var processedAnimations = this.processAnimations(animationProperties);\n      this.registerKeyframesUsage(processedAnimations);\n      var animationUpdates = this.getAnimationUpdates(processedAnimations);\n      this.attachedAnimations = processedAnimations;\n      if (animationUpdates) {\n        if (animationUpdates.animationNames && animationUpdates.animationNames.length === 0) {\n          this.detach();\n          return;\n        }\n        applyCSSAnimations(this.shadowNodeWrapper, animationUpdates);\n      }\n    }\n  }, {\n    key: \"unmountCleanup\",\n    value: function unmountCleanup() {\n      this.unregisterKeyframesUsage();\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this.attachedAnimations.length > 0) {\n        unregisterCSSAnimations(this.viewTag);\n        this.unregisterKeyframesUsage();\n        this.attachedAnimations = [];\n      }\n    }\n  }, {\n    key: \"registerKeyframesUsage\",\n    value: function registerKeyframesUsage(processedAnimations) {\n      var _this = this;\n      var newAnimationNames = new Set();\n      processedAnimations.forEach(function (_ref) {\n        var keyframesRule = _ref.keyframesRule;\n        cssKeyframesRegistry.add(keyframesRule, _this.viewName, _this.viewTag);\n        newAnimationNames.add(keyframesRule.name);\n      });\n      this.attachedAnimations.forEach(function (_ref2) {\n        var name = _ref2.keyframesRule.name;\n        if (!newAnimationNames.has(name)) {\n          cssKeyframesRegistry.remove(name, _this.viewName, _this.viewTag);\n        }\n      });\n    }\n  }, {\n    key: \"unregisterKeyframesUsage\",\n    value: function unregisterKeyframesUsage() {\n      var _this2 = this;\n      this.attachedAnimations.forEach(function (_ref3) {\n        var name = _ref3.keyframesRule.name;\n        cssKeyframesRegistry.remove(name, _this2.viewName, _this2.viewTag);\n      });\n    }\n  }, {\n    key: \"processAnimations\",\n    value: function processAnimations(animationProperties) {\n      var singleAnimationPropertiesArray = createSingleCSSAnimationProperties(animationProperties);\n      var processedAnimations = singleAnimationPropertiesArray.map(function (properties) {\n        var keyframes = properties.animationName;\n        var keyframesRule;\n        if (keyframes instanceof CSSKeyframesRuleImpl) {\n          keyframesRule = keyframes;\n        } else {\n          var _cssKeyframesRegistry;\n          var cssText = JSON.stringify(keyframes);\n          keyframesRule = (_cssKeyframesRegistry = cssKeyframesRegistry.get(cssText)) != null ? _cssKeyframesRegistry : new CSSKeyframesRuleImpl(keyframes, cssText);\n        }\n        return {\n          normalizedSettings: normalizeSingleCSSAnimationSettings(properties),\n          keyframesRule: keyframesRule\n        };\n      });\n      return processedAnimations;\n    }\n  }, {\n    key: \"buildAnimationsMap\",\n    value: function buildAnimationsMap(animations) {\n      return animations.reduceRight(function (acc, animation) {\n        var name = animation.keyframesRule.name;\n        if (!acc[name]) {\n          acc[name] = [animation];\n        } else {\n          acc[name].push(animation);\n        }\n        return acc;\n      }, {});\n    }\n  }, {\n    key: \"getAnimationUpdates\",\n    value: function getAnimationUpdates(processedAnimations) {\n      var newAnimationSettings = {};\n      var settingsUpdates = {};\n      var animationsArrayChanged = this.attachedAnimations.length !== processedAnimations.length;\n      var hasNewAnimations = false;\n      var hasSettingsUpdates = false;\n      var oldAnimations = this.buildAnimationsMap(this.attachedAnimations);\n      processedAnimations.forEach(function (_ref4, i) {\n        var _oldAnimations$keyfra;\n        var keyframesRule = _ref4.keyframesRule,\n          normalizedSettings = _ref4.normalizedSettings;\n        var oldAnimation = (_oldAnimations$keyfra = oldAnimations[keyframesRule.name]) == null ? void 0 : _oldAnimations$keyfra.pop();\n        if (!oldAnimation) {\n          hasNewAnimations = true;\n          animationsArrayChanged = true;\n          newAnimationSettings[i] = normalizedSettings;\n          return;\n        }\n        var updates = getAnimationSettingsUpdates(oldAnimation.normalizedSettings, normalizedSettings);\n        if (Object.keys(updates).length > 0) {\n          hasSettingsUpdates = true;\n          settingsUpdates[i] = updates;\n        }\n        if (oldAnimation.keyframesRule.name !== keyframesRule.name) {\n          animationsArrayChanged = true;\n        }\n      });\n      var result = {};\n      if (animationsArrayChanged) {\n        result.animationNames = processedAnimations.map(function (_ref5) {\n          var keyframesRule = _ref5.keyframesRule;\n          return keyframesRule.name;\n        });\n      }\n      if (hasNewAnimations) {\n        result.newAnimationSettings = newAnimationSettings;\n      }\n      if (hasSettingsUpdates) {\n        result.settingsUpdates = settingsUpdates;\n      }\n      if (hasNewAnimations || hasSettingsUpdates || animationsArrayChanged) {\n        return result;\n      }\n      return null;\n    }\n  }]);\n}();\nexport { CSSAnimationsManager as default };","map":{"version":3,"names":["_classCallCheck","_createClass","cssKeyframesRegistry","CSSKeyframesRuleImpl","createSingleCSSAnimationProperties","getAnimationSettingsUpdates","normalizeSingleCSSAnimationSettings","applyCSSAnimations","unregisterCSSAnimations","CSSAnimationsManager","shadowNodeWrapper","viewName","viewTag","attachedAnimations","key","value","update","animationProperties","detach","processedAnimations","processAnimations","registerKeyframesUsage","animationUpdates","getAnimationUpdates","animationNames","length","unmountCleanup","unregisterKeyframesUsage","_this","newAnimationNames","Set","forEach","_ref","keyframesRule","add","name","_ref2","has","remove","_this2","_ref3","singleAnimationPropertiesArray","map","properties","keyframes","animationName","_cssKeyframesRegistry","cssText","JSON","stringify","get","normalizedSettings","buildAnimationsMap","animations","reduceRight","acc","animation","push","newAnimationSettings","settingsUpdates","animationsArrayChanged","hasNewAnimations","hasSettingsUpdates","oldAnimations","_ref4","i","_oldAnimations$keyfra","oldAnimation","pop","updates","Object","keys","result","_ref5","default"],"sources":["C:\\Users\\asus\\Desktop\\V.E.T\\node_modules\\react-native-reanimated\\src\\css\\native\\managers\\CSSAnimationsManager.ts"],"sourcesContent":["'use strict';\nimport type { ShadowNodeWrapper } from '../../../commonTypes';\nimport type {\n  CSSAnimationKeyframes,\n  ExistingCSSAnimationProperties,\n  ICSSAnimationsManager,\n} from '../../types';\nimport { cssKeyframesRegistry, CSSKeyframesRuleImpl } from '../keyframes';\nimport {\n  createSingleCSSAnimationProperties,\n  getAnimationSettingsUpdates,\n  normalizeSingleCSSAnimationSettings,\n} from '../normalization';\nimport { applyCSSAnimations, unregisterCSSAnimations } from '../proxy';\nimport type {\n  CSSAnimationUpdates,\n  NormalizedSingleCSSAnimationSettings,\n} from '../types';\n\ntype ProcessedAnimation = {\n  normalizedSettings: NormalizedSingleCSSAnimationSettings;\n  keyframesRule: CSSKeyframesRuleImpl;\n};\n\nexport default class CSSAnimationsManager implements ICSSAnimationsManager {\n  private readonly shadowNodeWrapper: ShadowNodeWrapper;\n  private readonly viewName: string;\n  private readonly viewTag: number;\n\n  private attachedAnimations: ProcessedAnimation[] = [];\n\n  constructor(\n    shadowNodeWrapper: ShadowNodeWrapper,\n    viewName: string,\n    viewTag: number\n  ) {\n    this.shadowNodeWrapper = shadowNodeWrapper;\n    this.viewName = viewName;\n    this.viewTag = viewTag;\n  }\n\n  update(animationProperties: ExistingCSSAnimationProperties | null): void {\n    if (!animationProperties) {\n      this.detach();\n      return;\n    }\n\n    const processedAnimations = this.processAnimations(animationProperties);\n    this.registerKeyframesUsage(processedAnimations);\n\n    const animationUpdates = this.getAnimationUpdates(processedAnimations);\n    this.attachedAnimations = processedAnimations;\n\n    if (animationUpdates) {\n      if (\n        animationUpdates.animationNames &&\n        animationUpdates.animationNames.length === 0\n      ) {\n        this.detach();\n        return;\n      }\n\n      applyCSSAnimations(this.shadowNodeWrapper, animationUpdates);\n    }\n  }\n\n  unmountCleanup(): void {\n    this.unregisterKeyframesUsage();\n  }\n\n  private detach() {\n    if (this.attachedAnimations.length > 0) {\n      unregisterCSSAnimations(this.viewTag);\n      this.unregisterKeyframesUsage();\n      this.attachedAnimations = [];\n    }\n  }\n\n  private registerKeyframesUsage(processedAnimations: ProcessedAnimation[]) {\n    const newAnimationNames = new Set();\n\n    // Register keyframes for all new animations\n    processedAnimations.forEach(({ keyframesRule }) => {\n      cssKeyframesRegistry.add(keyframesRule, this.viewName, this.viewTag);\n      newAnimationNames.add(keyframesRule.name);\n    });\n\n    // Unregister keyframes for all old animations that are no longer attached\n    // to the view\n    this.attachedAnimations.forEach(({ keyframesRule: { name } }) => {\n      if (!newAnimationNames.has(name)) {\n        cssKeyframesRegistry.remove(name, this.viewName, this.viewTag);\n      }\n    });\n  }\n\n  private unregisterKeyframesUsage() {\n    // Unregister keyframes usage by the view (it is necessary to clean up\n    // keyframes from the CPP registry once all views that use them are unmounted)\n    this.attachedAnimations.forEach(({ keyframesRule: { name } }) => {\n      cssKeyframesRegistry.remove(name, this.viewName, this.viewTag);\n    });\n  }\n\n  private processAnimations(\n    animationProperties: ExistingCSSAnimationProperties\n  ): ProcessedAnimation[] {\n    const singleAnimationPropertiesArray =\n      createSingleCSSAnimationProperties(animationProperties);\n\n    const processedAnimations = singleAnimationPropertiesArray.map(\n      (properties) => {\n        const keyframes = properties.animationName;\n        let keyframesRule: CSSKeyframesRuleImpl;\n\n        if (keyframes instanceof CSSKeyframesRuleImpl) {\n          // If the instance of the CSSKeyframesRule class was passed, we can just compare\n          // references to the instance (css.keyframes() call should be memoized in order\n          // to preserve the same animation. If used inline, it will restart the animation\n          // on every component re-render)\n          keyframesRule = keyframes;\n        } else {\n          // If the keyframes are not an instance of the CSSKeyframesRule class (e.g. someone\n          // passes a keyframes object inline in the component's style without using css.keyframes()\n          // function), we don't want to restart the animation on every component re-render.\n          // In this case, we need to check if the animation with the same keyframes is already\n          // registered in the registry. If it is, we can just use the existing keyframes rule.\n          // Otherwise, we need to create a new keyframes rule.\n          const cssText = JSON.stringify(keyframes);\n          keyframesRule =\n            cssKeyframesRegistry.get(cssText) ??\n            new CSSKeyframesRuleImpl(\n              keyframes as CSSAnimationKeyframes,\n              cssText\n            );\n        }\n\n        return {\n          normalizedSettings: normalizeSingleCSSAnimationSettings(properties),\n          keyframesRule,\n        };\n      }\n    );\n\n    return processedAnimations;\n  }\n\n  private buildAnimationsMap(animations: ProcessedAnimation[]) {\n    // Iterate over attached animations from last to first for faster pop from\n    // the end of the array when removing used animations\n    return animations.reduceRight<Record<string, ProcessedAnimation[]>>(\n      (acc, animation) => {\n        const name = animation.keyframesRule.name;\n        if (!acc[name]) {\n          acc[name] = [animation];\n        } else {\n          acc[name].push(animation);\n        }\n        return acc;\n      },\n      {}\n    );\n  }\n\n  private getAnimationUpdates(\n    processedAnimations: ProcessedAnimation[]\n  ): CSSAnimationUpdates | null {\n    const newAnimationSettings: Record<\n      number,\n      NormalizedSingleCSSAnimationSettings\n    > = {};\n    const settingsUpdates: Record<\n      number,\n      Partial<NormalizedSingleCSSAnimationSettings>\n    > = {};\n\n    let animationsArrayChanged =\n      this.attachedAnimations.length !== processedAnimations.length;\n    let hasNewAnimations = false;\n    let hasSettingsUpdates = false;\n\n    const oldAnimations = this.buildAnimationsMap(this.attachedAnimations);\n\n    processedAnimations.forEach(({ keyframesRule, normalizedSettings }, i) => {\n      const oldAnimation = oldAnimations[keyframesRule.name]?.pop();\n\n      if (!oldAnimation) {\n        hasNewAnimations = true;\n        animationsArrayChanged = true;\n        newAnimationSettings[i] = normalizedSettings;\n        return;\n      }\n\n      const updates = getAnimationSettingsUpdates(\n        oldAnimation.normalizedSettings,\n        normalizedSettings\n      );\n\n      if (Object.keys(updates).length > 0) {\n        hasSettingsUpdates = true;\n        settingsUpdates[i] = updates;\n      }\n\n      if (oldAnimation.keyframesRule.name !== keyframesRule.name) {\n        animationsArrayChanged = true;\n      }\n    });\n\n    const result: CSSAnimationUpdates = {};\n    if (animationsArrayChanged) {\n      result.animationNames = processedAnimations.map(\n        ({ keyframesRule }) => keyframesRule.name\n      );\n    }\n    if (hasNewAnimations) {\n      result.newAnimationSettings = newAnimationSettings;\n    }\n    if (hasSettingsUpdates) {\n      result.settingsUpdates = settingsUpdates;\n    }\n\n    if (hasNewAnimations || hasSettingsUpdates || animationsArrayChanged) {\n      return result;\n    }\n\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}