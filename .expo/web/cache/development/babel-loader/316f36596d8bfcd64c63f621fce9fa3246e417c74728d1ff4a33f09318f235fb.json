{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { logger, ReanimatedError } from \"../../common\";\nimport { PERCENTAGE_REGEX } from \"../constants\";\nexport var ERROR_MESSAGES = {\n  invalidPointsCount: function invalidPointsCount() {\n    return `Invalid linear easing points count. There should be at least two points`;\n  },\n  invalidInputProgressValue: function invalidInputProgressValue(inputProgress) {\n    return `Invalid input progress ${inputProgress} value, it should be a percentage between 0% and 100%`;\n  }\n};\nexport var WARN_MESSAGES = {\n  inputProgressLessThanPrecedingPoint: function inputProgressLessThanPrecedingPoint(x, precedingX) {\n    return `Linear easing point x value ${x} is less than value of the preceding control point ${precedingX}. Value will be overridden by ${precedingX}`;\n  }\n};\nvar parsePercentage = function parsePercentage(percentage) {\n  var result;\n  if (typeof percentage === 'number') {\n    result = percentage;\n  } else if (PERCENTAGE_REGEX.test(percentage)) {\n    result = parseFloat(percentage) / 100;\n  }\n  if (result === undefined || result < 0 || result > 1) {\n    throw new ReanimatedError(ERROR_MESSAGES.invalidInputProgressValue(percentage));\n  }\n  return result;\n};\nvar extrapolate = function extrapolate(x, point1, point2) {\n  var slope = (point2.y - point1.y) / (point2.x - point1.x);\n  return point1.y + slope * (x - point1.x);\n};\nexport var LinearEasing = function () {\n  function LinearEasing(points) {\n    _classCallCheck(this, LinearEasing);\n    if (points.length < 2) {\n      throw new ReanimatedError(ERROR_MESSAGES.invalidPointsCount());\n    }\n    this.points = points.map(function (p) {\n      return Array.isArray(p) && p.length === 1 ? p[0] : p;\n    });\n  }\n  return _createClass(LinearEasing, [{\n    key: \"toString\",\n    value: function toString() {\n      return `${LinearEasing.easingName}(${this.points.map(function (point) {\n        return Array.isArray(point) ? `[${point.map(function (p) {\n          return typeof p === 'string' ? `\"${p}\"` : p;\n        }).join(', ')}]` : point;\n      }).join(', ')})`;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var points = this.canonicalize();\n      if (points[0].x > 0) {\n        points.unshift({\n          x: 0,\n          y: extrapolate(0, points[0], points[1])\n        });\n      }\n      if (points[points.length - 1].x < 1) {\n        points.push({\n          x: 1,\n          y: extrapolate(1, points[points.length - 2], points[points.length - 1])\n        });\n      }\n      return {\n        name: LinearEasing.easingName,\n        points: points\n      };\n    }\n  }, {\n    key: \"canonicalize\",\n    value: function canonicalize() {\n      var result = this.points.flatMap(function (point) {\n        return Array.isArray(point) ? point.slice(1).map(function (x) {\n          return {\n            x: parsePercentage(x),\n            y: point[0]\n          };\n        }) : [{\n          y: point\n        }];\n      });\n      if (result[0].x === undefined) {\n        result[0].x = 0;\n      }\n      if (result[result.length - 1].x === undefined) {\n        result[result.length - 1].x = 1;\n      }\n      var maxPrecedingX = 0;\n      for (var i = 1; i < result.length - 1; i++) {\n        var x = result[i].x;\n        if (x !== undefined) {\n          if (x < maxPrecedingX) {\n            logger.warn(WARN_MESSAGES.inputProgressLessThanPrecedingPoint(x, maxPrecedingX));\n            result[i].x = maxPrecedingX;\n          } else {\n            maxPrecedingX = x;\n          }\n        }\n      }\n      var precedingX = result[0].x;\n      var missingCount = 0;\n      for (var _i = 1; _i < result.length; _i++) {\n        var _x = result[_i].x;\n        if (_x === undefined) {\n          missingCount++;\n          continue;\n        }\n        if (missingCount > 0) {\n          var range = _x - precedingX;\n          for (var j = 0; j < missingCount; j++) {\n            result[_i - missingCount + j].x = precedingX + range * (j + 1) / (missingCount + 1);\n          }\n        }\n        precedingX = _x;\n        missingCount = 0;\n      }\n      return result;\n    }\n  }]);\n}();\nLinearEasing.easingName = 'linear';","map":{"version":3,"names":["_classCallCheck","_createClass","logger","ReanimatedError","PERCENTAGE_REGEX","ERROR_MESSAGES","invalidPointsCount","invalidInputProgressValue","inputProgress","WARN_MESSAGES","inputProgressLessThanPrecedingPoint","x","precedingX","parsePercentage","percentage","result","test","parseFloat","undefined","extrapolate","point1","point2","slope","y","LinearEasing","points","length","map","p","Array","isArray","key","value","toString","easingName","point","join","normalize","canonicalize","unshift","push","name","flatMap","slice","maxPrecedingX","i","warn","missingCount","range","j"],"sources":["C:\\Users\\asus\\Desktop\\V.E.T\\node_modules\\react-native-reanimated\\src\\css\\easing\\linear.ts"],"sourcesContent":["'use strict';\nimport { logger, ReanimatedError } from '../../common';\nimport { PERCENTAGE_REGEX } from '../constants';\nimport type { Point } from '../types';\nimport type {\n  ControlPoint,\n  NormalizedLinearEasing,\n  ParametrizedTimingFunction,\n} from './types';\n\nexport const ERROR_MESSAGES = {\n  invalidPointsCount: () =>\n    `Invalid linear easing points count. There should be at least two points`,\n  invalidInputProgressValue: (inputProgress: string | number) =>\n    `Invalid input progress ${inputProgress} value, it should be a percentage between 0% and 100%`,\n};\n\nexport const WARN_MESSAGES = {\n  inputProgressLessThanPrecedingPoint: (x: number, precedingX: number) =>\n    `Linear easing point x value ${x} is less than value of the preceding control point ${precedingX}. Value will be overridden by ${precedingX}`,\n};\n\nconst parsePercentage = (percentage: string | number): number => {\n  let result: number | undefined;\n  if (typeof percentage === 'number') {\n    result = percentage;\n  } else if (PERCENTAGE_REGEX.test(percentage)) {\n    result = parseFloat(percentage) / 100;\n  }\n\n  if (result === undefined || result < 0 || result > 1) {\n    throw new ReanimatedError(\n      ERROR_MESSAGES.invalidInputProgressValue(percentage)\n    );\n  }\n\n  return result;\n};\n\nconst extrapolate = (x: number, point1: Point, point2: Point) => {\n  const slope = (point2.y - point1.y) / (point2.x - point1.x);\n  return point1.y + slope * (x - point1.x);\n};\n\nexport class LinearEasing implements ParametrizedTimingFunction {\n  static readonly easingName = 'linear';\n  readonly points: ControlPoint[];\n\n  constructor(points: ControlPoint[]) {\n    if (points.length < 2) {\n      throw new ReanimatedError(ERROR_MESSAGES.invalidPointsCount());\n    }\n    this.points = points.map((p) =>\n      Array.isArray(p) && p.length === 1 ? p[0] : p\n    );\n  }\n\n  toString(): string {\n    return `${LinearEasing.easingName}(${this.points\n      .map((point) =>\n        Array.isArray(point)\n          ? `[${point.map((p) => (typeof p === 'string' ? `\"${p}\"` : p)).join(', ')}]`\n          : point\n      )\n      .join(', ')})`;\n  }\n\n  normalize(): NormalizedLinearEasing {\n    const points = this.canonicalize();\n\n    // Extrapolate points if the input progress of the first one is greater than 0\n    // or the input progress of the last one is less than 1\n    if (points[0].x > 0) {\n      points.unshift({ x: 0, y: extrapolate(0, points[0], points[1]) });\n    }\n    if (points[points.length - 1].x < 1) {\n      points.push({\n        x: 1,\n        y: extrapolate(1, points[points.length - 2], points[points.length - 1]),\n      });\n    }\n\n    return { name: LinearEasing.easingName, points };\n  }\n\n  private canonicalize() {\n    const result = this.points.flatMap<{ x?: number; y: number }>((point) =>\n      Array.isArray(point)\n        ? point.slice(1).map((x) => ({ x: parsePercentage(x), y: point[0] }))\n        : [{ y: point }]\n    );\n\n    // 1. If the first control point lacks an input progress value,\n    // set its input progress value to 0.\n    if (result[0].x === undefined) {\n      result[0].x = 0;\n    }\n\n    // 2.If the last control point lacks an input progress value,\n    // set its input progress value to 1.\n    if (result[result.length - 1].x === undefined) {\n      result[result.length - 1].x = 1;\n    }\n\n    // 3. If any control point has an input progress value that is less\n    // than the input progress value of any preceding control point, set\n    // its input progress value to the largest input progress value of\n    // any preceding control point.\n    let maxPrecedingX = 0;\n    for (let i = 1; i < result.length - 1; i++) {\n      const x = result[i].x;\n      if (x !== undefined) {\n        if (x < maxPrecedingX) {\n          logger.warn(\n            WARN_MESSAGES.inputProgressLessThanPrecedingPoint(x, maxPrecedingX)\n          );\n          result[i].x = maxPrecedingX;\n        } else {\n          maxPrecedingX = x;\n        }\n      }\n    }\n\n    // 4. If any control point still lacks an input progress value, then\n    // for each contiguous run of such control points, set their input\n    // progress values so that they are evenly spaced between the preceding\n    // and following control points with input progress values.\n    let precedingX = result[0].x;\n    let missingCount = 0;\n    for (let i = 1; i < result.length; i++) {\n      const x = result[i].x;\n\n      if (x === undefined) {\n        missingCount++;\n        continue;\n      }\n\n      if (missingCount > 0) {\n        const range = x - precedingX;\n\n        for (let j = 0; j < missingCount; j++) {\n          result[i - missingCount + j].x =\n            precedingX + (range * (j + 1)) / (missingCount + 1);\n        }\n      }\n\n      precedingX = x;\n      missingCount = 0;\n    }\n\n    return result as Point[];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}